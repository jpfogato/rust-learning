Ownership

It enables Rust to make memory safety guarantees without needing a garbage collector
Safety is the absence of undefined behavior!
Rust’s goal is to compile programs into efficient binaries that require as few runtime checks as possible.
Rust does not check for variable definitions at run-time. Instead it validates the program at compile-time.
Rust does not allow you to interpret memory as an array of bytes

Variables live in the Stack within "frames".
A frame is a mapping from variables to values within a single scope, such as a function.
After a function returns, Rust deallocates the function’s frame (freeing or dropping).

Boxes live in the Heap.
Heap data is not tied to a specific stack frame.

The stack holds data associated with a specific function, while the heap holds data that can outlive a function

Rust Does Not Permit Manual Memory Management
There are no "free" keywords to be used as it is unsafe to try to read a pointer to an address that have been deallocated

Box deallocation principle: If a variable owns a box, when Rust deallocates the variable’s frame, then Rust deallocates the box’s heap memory associated with it.

Boxes are used by Rust data structures1 like Vec, String, and HashMap to hold a variable number of elements.

Moved heap data principle: if a variable x moves ownership of heap data to another variable y, then x cannot be used after the move.

Ownership is primarily a discipline of heap management:

        -> All heap data must be owned by exactly one variable.
        -> Rust deallocates heap data once its owner goes out of scope.
        -> Ownership can be transferred by moves, which happen on assignments and function calls.
        -> Heap data can only be accessed through its current owner, not a previous owner.

## References and Borrowing

Ownership can be moved from the original variable on main to a called function, which are then removed from the stack since they transferred the ownership of the heap memory associated with them to the input parameters of the function called. To avoid that, we can use references (&).

This is also known as "borrowing"

Referrences are non-owning pointers because they do not own the data they point to

Dereferences use the "*" operator

Rust implicitly inserts dereferences and references in certain cases, such as calling a method with the dot operator

Rust Avoids Simultaneous Aliasing and Mutation

For instance: If a reference to a Vec index is created and later this Vec recieves a .push(), the original pointer is dropped because Rust has to allocate new memory, copy the data to this new location, and -> drop the original heap allocation!! <- so any variables that were using a pointer to this Vec via '&v[index]' becomes invalid after a push since the pointer is freed.

Pointer Safety Principle: data should never be aliased and mutated at the same time.


Variables have three kinds of permissons on their data:
        -> Read (R): Data can be copied to another location
        -> Write (W): Data can be mutated
        -> Own (O): Data can be moved or dropped
        -> Flow (F): Expected whenever an expression uses an input our output reference, like &...

These permissions DO NOT EXISTS AT RUN-TIME, only within the compiller

Default behavior: R+O
If annotated with 'let mut', then it has: R+O+W

A reference can temporarily remove these permissions

Permissions are defined on places, not just variables. A place is anything you can put on the left hand of an assignment, such as:
        - variables (x)
        - dereferences of places (*x)
        - array accesses of places (x[0])
        - fields of places (x.0 for tuples or a.field for structs)
        - any combination of the above: *((*a)[0].1)

mutable references: &mut

Data Must Outlive All Of Its References

input/output references are treated differently than references within a function body
Rust uses a different mechanism, the F permission, to check the safety of those references.

returns of references to a local variables that gets destroyed when the function ends is unsafe

All variables can read, own, and (optionally) write their data.
Creating a reference will transfer permissions from the borrowed place to the reference.
Permissions are returned once the reference’s lifetime has ended.
Data must outlive all references that point to it.

fn example_fn(a: String, b: &str, c: &mut str) {}
The example_fn above has:
        -> a: a moving of ownership from the variable that calls this function to the function itself
        -> b: a read ownly borrow of a variable of type str
        -> c: a mutable borrow of a variable of type str

Continue from here:
https://rust-book.cs.brown.edu/ch04-03-fixing-ownership-errors.html