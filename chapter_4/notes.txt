Ownership

It enables Rust to make memory safety guarantees without needing a garbage collector
Safety is the absence of undefined behavior!
Rust’s goal is to compile programs into efficient binaries that require as few runtime checks as possible.
Rust does not check for variable definitions at run-time. Instead it validates the program at compile-time.
Rust does not allow you to interpret memory as an array of bytes

Variables live in the Stack within "frames".
A frame is a mapping from variables to values within a single scope, such as a function.
After a function returns, Rust deallocates the function’s frame (freeing or dropping).

Boxes live in the Heap.
Heap data is not tied to a specific stack frame.

The stack holds data associated with a specific function, while the heap holds data that can outlive a function

Rust Does Not Permit Manual Memory Management
There are no "free" keywords to be used as it is unsafe to try to read a pointer to an address that have been deallocated

Box deallocation principle: If a variable owns a box, when Rust deallocates the variable’s frame, then Rust deallocates the box’s heap memory associated with it.

Boxes are used by Rust data structures1 like Vec, String, and HashMap to hold a variable number of elements.

Moved heap data principle: if a variable x moves ownership of heap data to another variable y, then x cannot be used after the move.

Ownership is primarily a discipline of heap management:

        -> All heap data must be owned by exactly one variable.
        -> Rust deallocates heap data once its owner goes out of scope.
        -> Ownership can be transferred by moves, which happen on assignments and function calls.
        -> Heap data can only be accessed through its current owner, not a previous owner.

## References and Borrowing

Ownership can be moved from the original variable on main to a called function, which are then removed from the stack since they transferred the ownership of the heap memory associated with them to the input parameters of the function called. To avoid that, we can use references (&).

This is also known as "borrowing"

Referrences are non-owning pointers because they do not own the data they point to

Dereferences use the "*" operator

Rust implicitly inserts dereferences and references in certain cases, such as calling a method with the dot operator

Rust Avoids Simultaneous Aliasing and Mutation

For instance: If a reference to a Vec index is created and later this Vec recieves a .push(), the original pointer is dropped because Rust has to allocate new memory, copy the data to this new location, and -> drop the original heap allocation!! <- so any variables that were using a pointer to this Vec via '&v[index]' becomes invalid after a push since the pointer is freed.

Pointer Safety Principle: data should never be aliased and mutated at the same time.


Variables have three kinds of permissons on their data:
        -> Read (R): Data can be copied to another location
        -> Write (W): Data can be mutated
        -> Own (O): Data can be moved or dropped
        -> Flow (F): Expected whenever an expression uses an input our output reference, like &...

These permissions DO NOT EXISTS AT RUN-TIME, only within the compiller

Default behavior: R+O
If annotated with 'let mut', then it has: R+O+W

A reference can temporarily remove these permissions

Permissions are defined on places, not just variables. A place is anything you can put on the left hand of an assignment, such as:
        - variables (x)
        - dereferences of places (*x)
        - array accesses of places (x[0])
        - fields of places (x.0 for tuples or a.field for structs)
        - any combination of the above: *((*a)[0].1)

mutable references: &mut

Data Must Outlive All Of Its References

input/output references are treated differently than references within a function body
Rust uses a different mechanism, the F permission, to check the safety of those references.

returns of references to a local variables that gets destroyed when the function ends is unsafe

All variables can read, own, and (optionally) write their data.
Creating a reference will transfer permissions from the borrowed place to the reference.
Permissions are returned once the reference’s lifetime has ended.
Data must outlive all references that point to it.

fn example_fn(a: String, b: &str, c: &mut str) {}
The example_fn above has:
        -> a: a moving of ownership from the variable that calls this function to the function itself
        -> b: a read ownly borrow of a variable of type str
        -> c: a mutable borrow of a variable of type str

### Ownership errors

Functions should not mutate their inputs if the caller would not expect it
A stack frame cannot have its lifetime extended
If a value does not own heap data, then it can be copied without a move:
        - An i32 does not own heap data, so it can be copied without a move.
        - A String does own heap data, so it can not be copied without a move.
        - An &String does not own heap data, so it can be copied without a move.

Unsafe blocks allow the use of “raw” pointers, which are not checked for safety by the borrow checker

## Slice Type

allow reference a contiguous sequence from a collection, without referencing the whole collection -> non-owning pointer

We create slices using a range within brackets by specifying [starting_index..ending_index]

these are equal: 
        _ = &s[0..2];
        _ = &s[..2];


these are also equal (let len = s.len();)

        _ = &s[0..len];
        _ = &s[..];

Because slices are references, they also change the permissions on referenced data. If a string is referenced, the original variable loses W and O permissions to itself.

The type &String is a normal reference consisting of a single pointer, so 8 bytes on a 64-bit architecture. The type &str is a special slice reference which consists of a pointer and a length, so 16 bytes. 


----------

Review: 

The point of this example is to say: if Rust is not your first language, then you already have experience working with memory and pointers! Rust just makes those concepts explicit. This has the dual benefit of (1) improving runtime performance by avoiding garbage collection, and (2) improving predictability by preventing accidental “leaks” of data.

By adding a * to the variable you are trying to use, we are actually pointing to the heap allocation of that data, not to the stack pointer!

Borrowing a variable (creating a reference to it) temporarily removes some of the variable’s permissions
An immutable borrow creates an immutable reference, and also disables the borrowed data from being mutated or moved

Mutating an immutable reference is not ok
Mutating the immutably borrowed data is not ok
Moving data out of the reference is not ok
