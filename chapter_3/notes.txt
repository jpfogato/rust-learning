it is important to learn the keywords. They are here:
https://doc.rust-lang.org/book/appendix-01-keywords.html

## 3.1 Variables

Differences between a constant and a variable
    Constants are not allowed to be mutable
    Constant declaration: const
    Variable declaration: let
    Type of the value for a constant MUST be annotated (const CONSTANT : <Type> = "value";)

Rust’s naming convention for constants is to use all uppercase with underscores between words

Shadowing a variable in an inner scope, does not mutate its value in an outer scope

Rust is a statically typed language, which means that it must know the types of all variables at compile time

To get a very detailed explanation of an error detected at compile time we can use:
    rustc --explain <ERROR_CODE>

## 3.2 Data Types

Rust has four primary scalar types:
- integers: 
    - number without a fractional component (i or u -> 8, 16, 32, 64, 128 bits).
    - Integer literals support decimal, hex, octal, binary and byte notations
    - consider explicitly handling overflows when manipulating integers by using these methods:
        Example: adding 10 to 250 results in an overflow
        wrapping_* -> wrapping_add: 250 + 10 = 4
        checked_* -> checked_add: overflow!
        overflowing_* -> overflowing_add: 4, overflow? true
        staurating_* -> saturating_add: 255
    - division truncates toward zero to the nearest integer

- floating-point numbers: 
    - numbers with decimal points (f32 and f64 (default))
    - all operators allowed in Rust are described here: https://doc.rust-lang.org/book/appendix-02-operators.html
    
- Booleans
    - one byte in size
    - specified using bool, values: true, false

- characters
    - the language’s most primitive alphabetic type
    - char type is four bytes in size and represents a Unicode scalar value

Rust has two primitive compound types:
- Tuple:
    - general way of grouping together various types into one compound type
    - they cannot grow or shrink after declaration
    - expressions implicitly return the unit value (a tuple with nothing in it) if they don’t return any other value

- Array:
    - groups variables of the same type
    - must have a fixed length
    - arrays are stored at the stack. Vectors are stored in the heap -> vectors can grow or shrink. Arrays cannot
    - if you don't know if you need a vector an array, you probably need a vector

## 3.3 Functions

Rust code uses snake case as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words.

Rust doesn’t care where you define your functions, only that they’re defined somewhere in a scope that can be seen by the caller

Parameters (arguments) are variables that are part of a function's signature

It is required to declare the parameter types in the function signature.

Rust is an expression-based language:
    - Statements are instructions that perform some action and do not return a value. This means you cannot assign a statement to a variable.
    - Expressions evaluate to a resultant value. They do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value.

Return values types are specified in the signature with an arrow ->

We can return a function early by calling "return" keyword.

The value returned by the function is the latest expression evaluated if not explicitly told otherwise
