it is important to learn the keywords. They are here:
https://doc.rust-lang.org/book/appendix-01-keywords.html

## 3.1 Variables

Differences between a constant and a variable
    Constants are not allowed to be mutable
    Constant declaration: const
    Variable declaration: let
    Type of the value for a constant MUST be annotated (const CONSTANT : <Type> = "value";)

Rust’s naming convention for constants is to use all uppercase with underscores between words

Shadowing a variable in an inner scope, does not mutate its value in an outer scope

Rust is a statically typed language, which means that it must know the types of all variables at compile time

To get a very detailed explanation of an error detected at compile time we can use:
    rustc --explain <ERROR_CODE>

## 3.2 Data Types

Rust has four primary scalar types:
- integers: 
    - number without a fractional component (i or u -> 8, 16, 32, 64, 128 bits).
    - Integer literals support decimal, hex, octal, binary and byte notations
    - consider explicitly handling overflows when manipulating integers by using these methods:
        Example: adding 10 to 250 results in an overflow
        wrapping_* -> wrapping_add: 250 + 10 = 4
        checked_* -> checked_add: overflow!
        overflowing_* -> overflowing_add: 4, overflow? true
        staurating_* -> saturating_add: 255
    - division truncates toward zero to the nearest integer

- floating-point numbers: 
    - numbers with decimal points (f32 and f64 (default))
    - all operators allowed in Rust are described here: https://doc.rust-lang.org/book/appendix-02-operators.html
    
- Booleans
    - one byte in size
    - specified using bool, values: true, false

- characters
    - the language’s most primitive alphabetic type
    - char type is four bytes in size and represents a Unicode scalar value

Rust has two primitive compound types:
- Tuple:
    - general way of grouping together various types into one compound type
    - they cannot grow or shrink after declaration
    - expressions implicitly return the unit value (a tuple with nothing in it) if they don’t return any other value

- Array:
    - groups variables of the same type
    - must have a fixed length
    - arrays are stored at the stack. Vectors are stored in the heap -> vectors can grow or shrink. Arrays cannot
    - if you don't know if you need a vector an array, you probably need a vector

## 3.3 Functions

Rust code uses snake case as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words.

Rust doesn’t care where you define your functions, only that they’re defined somewhere in a scope that can be seen by the caller

Parameters (arguments) are variables that are part of a function's signature

It is required to declare the parameter types in the function signature.

Rust is an expression-based language:
    - Statements are instructions that perform some action and do not return a value. This means you cannot assign a statement to a variable.
    - Expressions evaluate to a resultant value. They do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value.

Return values types are specified in the signature with an arrow ->

We can return a function early by calling "return" keyword.

The value returned by the function is the latest expression evaluated if not explicitly told otherwise

## 3.4 Comments

Compiller ignores it and they are not included in the binaries.
Single line syntax: // single line comment
Multiple line syntax: /* <comments spamming multiple lines> */

Place comments above the code it is annotating.

This section does not includes a source code.

## 3.5  Control Flow


### if

If expressions allows for branching of code depending on conditions.
The block of code to execute if "true" goes immediately after the "if" condition.
If no option to execute code with an "else" condition, the "if" block is skipped if the condition is "false".
The condition MUST be of a bool type. If this happens, the compiller throws this error: error[E0308]: mismatched types (expected `bool`, found integer)
If a condition is evaluated to "true", the block of code associated with it executes and the program exits the "if" block, so if more than one of the arms would evaluate to "true", only the first called will be executed.
If the code contains more than ONE "else if" a refactoring is suggested. In this case, use the "match" construct (chapter 6).
Because if is an expression, we can use it in the right side of a statement to assign a value conditionally. Values that have the potential of being results of the if statement must be of the same type!

### loop

loop keyword executes a block of code forever or until rust is told otherwise.
To exit a loop, use the "break" or the "continue" keywords.
use a single quote to lable to loop so it can be closed from nested loops conditionally

(CONTINUE AT: Conditional Loops with while)
